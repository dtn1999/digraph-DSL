/* generated from model GraphQLLite */
/* generated by template core.Class*/

/* (c) https://github.com/MontiCore/monticore */
package graphqllite._symboltable;

/* generated by template core.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.monticore.ast.ASTNode;
import de.monticore.ast.Comment;
import de.se_rwth.commons.SourcePosition;
import de.monticore.symboltable.*;
import de.monticore.ast.ASTCNode;


 public  class TypeSymbol extends graphqllite._symboltable.GQLTypeSymbol  implements graphqllite._symboltable.ICommonGraphQLLiteSymbol,de.monticore.symboltable.IScopeSpanningSymbol {

    /* generated by template core.Attribute*/
 protected  graphqllite._symboltable.IGraphQLLiteScope spannedScope ;


    /* generated by template core.Constructor*/
 public  TypeSymbol(String name)
 {
  super(name);
}


    /* generated by template core.Method*/
 public  graphqllite._symboltable.IGraphQLLiteScope getEnclosingScope ()

 {
      /* generated by template _symboltable.symbol.GetScope*/

if (enclosingScope instanceof graphqllite._symboltable.IGraphQLLiteScope) {
  return (graphqllite._symboltable.IGraphQLLiteScope) enclosingScope;
} else {
  de.se_rwth.commons.logging.Log.error("0xA7006x25531 enclosingScope could not be casted to the type graphqllite._symboltable.IGraphQLLiteScope.");
}
// Normally this statement is not reachable
throw new IllegalStateException();
}

    /* generated by template core.Method*/
 public  void setEnclosingScope (graphqllite._symboltable.IGraphQLLiteScope scope)

 {
      enclosingScope = scope;
}

    /* generated by template core.Method*/
 public  graphqllite._ast.ASTType getAstNode ()

 {
      return (graphqllite._ast.ASTType) super.getAstNode();
}

    /* generated by template core.Method*/
 public  void accept (graphqllite._visitor.GraphQLLiteTraverser visitor)

 {
      visitor.handle(this);
}

    /* generated by template core.Method*/
 protected  String determinePackageName ()

 {
      /* generated by template _symboltable.symbol.DeterminePackageName*/

de.monticore.symboltable.IScope optCurrentScope = enclosingScope;
while (optCurrentScope != null) {
final de.monticore.symboltable.IScope currentScope = optCurrentScope;
    if (currentScope.isPresentSpanningSymbol()) {
      // If one of the enclosing scope(s) is spanned by a symbol, take its
      // package name. This check is important, since the package name of the
      // enclosing symbol might be set manually.
      return currentScope.getSpanningSymbol().getPackageName();
    } else if (currentScope instanceof de.monticore.symboltable.IArtifactScope) {
      return ((de.monticore.symboltable.IArtifactScope) currentScope).getPackageName();
    }
optCurrentScope = currentScope.getEnclosingScope();
  }
  return "";
}

    /* generated by template core.Method*/
 protected  String determineFullName ()

 {
      /* generated by template _symboltable.symbol.DetermineFullName*/

  if (enclosingScope == null) {
    // There should not be a symbol that is not defined in any scope. This case should only
    // occur while the symbol is built (by the symbol table creator). So, here the full name
    // should not be cached yet.
    return name;
  }

  final Deque<String> nameParts = new ArrayDeque<>();
    nameParts.addFirst(name);

    de.monticore.symboltable.IScope optCurrentScope = getEnclosingScope();

  while (optCurrentScope != null) {
  final de.monticore.symboltable.IScope currentScope = optCurrentScope;
      if (currentScope.isPresentSpanningSymbol()) {
        // If one of the enclosing scope(s) is spanned by a symbol, the full name
        // of that symbol is the missing prefix, and hence, the calculation
        // ends here. This check is important, since the full name of the enclosing
        // symbol might be set manually.
        nameParts.addFirst(currentScope.getSpanningSymbol().getFullName());
        break;
      }

      if (!(currentScope instanceof de.monticore.symboltable.IGlobalScope)) {
        if (currentScope instanceof de.monticore.symboltable.IArtifactScope) {
          // We have reached the artifact scope. Get the package name from the
          // symbol itself, since it might be set manually.
          if (!getPackageName().isEmpty()) {
            nameParts.addFirst(getPackageName());
          }
        } else {
          if (currentScope.isPresentName()) {
            nameParts.addFirst(currentScope.getName());
          }
          // ...else stop? If one of the enclosing scopes is unnamed,
          //         the full name is same as the simple name.
        }
  optCurrentScope = currentScope.getEnclosingScope();
  } else {
  break;
  }
    }

    return de.se_rwth.commons.Names.getQualifiedName(nameParts);

}

    /* generated by template core.Method*/
 public  graphqllite._symboltable.IGraphQLLiteScope getSpannedScope ()

 {
      /* generated by template _symboltable.symbol.GetScope*/

if (spannedScope instanceof graphqllite._symboltable.IGraphQLLiteScope) {
  return (graphqllite._symboltable.IGraphQLLiteScope) spannedScope;
} else {
  de.se_rwth.commons.logging.Log.error("0xA7006x42747 spannedScope could not be casted to the type graphqllite._symboltable.IGraphQLLiteScope.");
}
// Normally this statement is not reachable
throw new IllegalStateException();
}

    /* generated by template core.Method*/
 public  void setSpannedScope (graphqllite._symboltable.IGraphQLLiteScope scope)

 {
      /* generated by template _symboltable.symbol.SetSpannedScope*/
  if (scope != null) {
    this.spannedScope = scope;
    this.spannedScope.setSpanningSymbol(this);
  }
}

}
